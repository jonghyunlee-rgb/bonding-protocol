<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bonding Written Test</title>
  <style>
    :root{
      --red:#d5302c;
      --purple:#6a33c9;
      --border:#d0d0d0;
      --muted:#666;
      --chip:#f2f2f2;
    }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 16px;
    }

    h2{
      margin: 0 0 12px;
      font-size: clamp(1.15rem, 3.8vw, 1.6rem);
      line-height: 1.25;
    }

    /* Controls: responsive */
    .controls{
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      max-width: 1100px;
    }
    @media (min-width: 700px){
      .controls{
        grid-template-columns: auto 1fr auto auto auto;
        gap: 10px;
      }
    }

    label{ font-weight: 700; }

    select, button{
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: white;
      font-size: 16px; /* prevents iOS zoom on focus */
      width: 100%;
    }
    @media (min-width: 700px){
      select, button{ width: auto; }
    }

    button{ cursor: pointer; }
    button:active{ transform: translateY(1px); }

    .hint{
      margin: 8px 0 14px;
      color: var(--muted);
      font-size: 0.95rem;
      max-width: 1100px;
      line-height: 1.4;
    }

    .list{ max-width: 1100px; }

    /* Steps: responsive layout */
    .step{
      display: grid;
      grid-template-columns: 32px 1fr;
      gap: 10px;
      line-height: 1.85;
      font-size: clamp(1rem, 3.3vw, 1.08rem);
      margin: 10px 0;
      align-items: start;
    }
    @media (min-width: 700px){
      .step{ grid-template-columns: 40px 1fr; }
    }

    .num{
      text-align: right;
      opacity: 0.85;
      font-weight: 700;
    }
    .text{
      word-break: break-word;
    }

    .red{ color: var(--red); font-weight: 650; }
    .purple{ color: var(--purple); font-weight: 650; }

    /* word tokens - better tap targets on phone */
    .w{
      padding: 3px 3px;
      border-radius: 8px;
    }
    .hidden{
      color: transparent !important;
      background: var(--chip);
      border: 1px solid #e0e0e0;
      user-select: none;
      padding: 3px 6px; /* bigger */
      margin: 0 1px;   /* breathing room */
    }
    .hidden::selection{ background: transparent; }

    .space{ white-space: pre; }
  </style>
</head>

<body>
  <!-- Title: do not change -->
  <h2>Steps in 4<sup>th</sup> generation bonding (Optibond FL&reg;)</h2>

  <div class="controls">
    <label for="level">Difficulty</label>

    <select id="level">
      <option value="1" selected>LV1: hide 3–4 words</option>
      <option value="2">LV2: hide half the words</option>
      <option value="3">LV3: only first word shows</option>
    </select>

    <button id="reroll" type="button">Reroll</button>
    <button id="reveal" type="button">Reveal All</button>
    <button id="generate" type="button">Generate</button>
  </div>

  <div class="hint">
    Red = keywords/critical steps. Purple = rationale/understanding.
    Hidden words are tappable (tap to reveal that one word).
  </div>

  <div id="app" class="list"></div>

<script>
const STEPS = [
  { n: 1, segments: [
    { cls: "red", text: "Etch all prepared enamel surfaces with 37.5% phosphoric acid for 20 seconds." },
    { cls: "purple", text: " Etch beyond the finish line." },
  ]},
  { n: 2, segments: [
    { cls: "red", text: "Rinse thoroughly" },
    { cls: "normal", text: " with a " },
    { cls: "purple", text: "3-way air/water syringe" },
    { cls: "red", text: " for 20 seconds after all traces of the etchant disappear." },
  ]},
  { n: 3, segments: [
    { cls: "purple", text: "3-way air/water syringe " },
    { cls: "red", text: "air dry the enamel to check for a frosty, white appearance " },
    { cls: "normal", text: "to " },
    { cls: "purple", text: "indicate proper enamel etching." },
  ]},
  { n: 4, segments: [
    { cls: "red", text: "Etch all non-sclerotic dentin surfaces with 37.5% phosphoric acid for 5-10 seconds and all sclerotic dentin surfaces with 37.5% phosphoric acid for 15-20 seconds." },
  ]},
  { n: 5, segments: [
    { cls: "red", text: "Rinse thoroughly for 20 seconds after all traces of the etchant disappear." },
  ]},
  { n: 6, segments: [
    { cls: "red", text: "Aspirate " },
    { cls: "purple", text: "the excess rinse " },
    { cls: "red", text: "water with high volume evacuation leaving a shiny, non-desiccated layer of dentin." },
  ]},
  { n: 7, segments: [
    { cls: "normal", text: "Using a " },
    { cls: "red", text: "Microbrush\u00AE" },
    { cls: "red", text: ", apply the primer" },
    { cls: "normal", text: " with a gentle " },
    { cls: "red", text: "circular scrubbing motion in 4-5 overlapping coats for all dentin areas." },
  ]},
  { n: 8, segments: [
    { cls: "red", text: "Aspirate " },
    { cls: "normal", text: "with " },
    { cls: "purple", text: "high volume evacuation " },
    { cls: "normal", text: "for " },
    { cls: "red", text: "5 seconds " },
    { cls: "purple", text: "to evaporate the solvent in the primer." },
  ]},
  { n: 9, segments: [
    { cls: "normal", text: "Using a " },
    { cls: "red", text: "new Microbrush\u00AE" },
    { cls: "red", text: ", apply the adhesive " },
    { cls: "normal", text: "material " },
    { cls: "purple", text: "in an even layer " },
    { cls: "red", text: "over all etched enamel and dentin. " },
    { cls: "purple", text: "Be careful not to use an excessive amount." },
  ]},
  { n: 10, segments: [
    { cls: "normal", text: "Use a light amount of high volume evacuation to thin the adhesive if you so desire. Eliminating this step has no detrimental effect on the outcome because this is a highly filled adhesive." },
  ]},
  { n: 11, segments: [
    { cls: "purple", text: "Using a curing light, " },
    { cls: "red", text: "cure the adhesive for 20 seconds per surface." },
  ]},
  { n: 12, segments: [
    { cls: "purple", text: "Incrementally " },
    { cls: "red", text: "add composite " },
    { cls: "purple", text: "in layers up to 2 mm " },
    { cls: "red", text: "thick," },
    { cls: "purple", text: " sculpting and perfecting anatomy, surface, margins, and contours prior to light curing." },
  ]},
  { n: 13, segments: [
    { cls: "red", text: "After curing the last increment, add a layer of glycerine gel over the surface" },
    { cls: "normal", text: " to prevent any " },
    { cls: "purple", text: "oxygen contact to the surface." },
  ]},
  { n: 14, segments: [
    { cls: "normal", text: "Using a " },
    { cls: "red", text: "curing light," },
    { cls: "normal", text: " cure " },
    { cls: "purple", text: "through the glycerine gel for " },
    { cls: "red", text: "10 seconds per surface to eliminate " },
    { cls: "purple", text: "the oxygen-inhibited layer and completely harden the restoration\u2019s surface." },
  ]},
  { n: 15, segments: [
    { cls: "red", text: "Contour" },
    { cls: "normal", text: " and " },
    { cls: "red", text: "polish" },
    { cls: "normal", text: " as necessary with " },
    { cls: "purple", text: "appropriate rotary" },
    { cls: "normal", text: " and " },
    { cls: "purple", text: "other instruments." },
  ]},
];

// tokenize while preserving spaces
function splitToWordTokens(text) {
  return text.split(/(\s+)/).filter(t => t.length > 0);
}

function buildTokensFromSteps(steps) {
  return steps.map(step => {
    const tokens = [];
    step.segments.forEach(seg => {
      const parts = splitToWordTokens(seg.text);
      parts.forEach(p => {
        const isSpace = /^\s+$/.test(p);
        tokens.push({ t: p, cls: seg.cls || "normal", isSpace });
      });
    });
    return { n: step.n, tokens };
  });
}

function sampleIndices(wordTokenIndices, k) {
  const arr = [...wordTokenIndices];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return new Set(arr.slice(0, Math.max(0, Math.min(k, arr.length))));
}

function hiddenSetForLevel(stepTokens, level) {
  const wordIdx = [];
  stepTokens.forEach((tok, idx) => { if (!tok.isSpace) wordIdx.push(idx); });
  if (wordIdx.length <= 1) return new Set(); // keep at least 1 visible word

  if (level === 3) {
    const hidden = new Set();
    const first = wordIdx[0];
    wordIdx.forEach(i => { if (i !== first) hidden.add(i); });
    return hidden;
  }

  if (level === 1) {
    const maxHide = Math.max(0, wordIdx.length - 1);
    const target = Math.min(maxHide, Math.min(4, Math.max(3, wordIdx.length)));
    return sampleIndices(wordIdx, target);
  }

  // level === 2
  const maxHide = Math.max(0, wordIdx.length - 1);
  const target = Math.min(maxHide, Math.floor(wordIdx.length / 2));
  return sampleIndices(wordIdx, target);
}

// render
const TOKENIZED = buildTokensFromSteps(STEPS);
let hiddenByStep = new Map();
let revealAll = false;

function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  TOKENIZED.forEach(step => {
    const row = document.createElement("div");
    row.className = "step";

    const num = document.createElement("div");
    num.className = "num";
    num.textContent = step.n + ".";
    row.appendChild(num);

    const text = document.createElement("div");
    text.className = "text";

    const hiddenSet = hiddenByStep.get(step.n) || new Set();

    step.tokens.forEach((tok, idx) => {
      if (tok.isSpace) {
        const s = document.createElement("span");
        s.className = "space";
        s.textContent = tok.t;
        text.appendChild(s);
        return;
      }

      const w = document.createElement("span");
      w.className = `w ${tok.cls}`;

      const shouldHide = !revealAll && hiddenSet.has(idx);

      if (shouldHide) {
        w.classList.add("hidden");
        w.textContent = "█".repeat(Math.max(2, tok.t.length));
        w.title = "Tap to reveal";
        w.style.cursor = "pointer";
        w.addEventListener("click", () => {
          hiddenSet.delete(idx);
          hiddenByStep.set(step.n, hiddenSet);
          render();
        });
      } else {
        w.textContent = tok.t;
      }

      text.appendChild(w);
    });

    row.appendChild(text);
    app.appendChild(row);
  });
}

function generateHidden() {
  revealAll = false;
  const level = Number(document.getElementById("level").value);
  hiddenByStep = new Map();
  TOKENIZED.forEach(step => hiddenByStep.set(step.n, hiddenSetForLevel(step.tokens, level)));
  render();
}

// events
document.getElementById("generate").addEventListener("click", generateHidden);
document.getElementById("reroll").addEventListener("click", generateHidden);
document.getElementById("reveal").addEventListener("click", () => { revealAll = true; render(); });

// ✅ default pre-generated + auto-regenerate when changing level
document.getElementById("level").addEventListener("change", generateHidden);
window.addEventListener("DOMContentLoaded", generateHidden);
</script>
</body>
</html>
